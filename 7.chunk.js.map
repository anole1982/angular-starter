{"version":3,"file":"7.chunk.js","sources":["webpack:///./src/app/+demo/+crypto/crypto.component.ts","webpack:///./src/app/+demo/+crypto/crypto.service.ts","webpack:///./src/app/+demo/+crypto/crypto.module.ts","webpack:///./src/app/+demo/+crypto/crypto.routes.ts","webpack:///./src/app/+demo/+crypto/index.ts"],"sourcesContent":["import {\n  Component,\n  OnInit,\n  ViewChild,\n  ElementRef\n} from '@angular/core';\nimport { CryptoService } from './crypto.service';\nconsole.log('`Web rtc` component loaded asynchronously');\n\n@Component({\n  selector: 'webrtc',\n  template: `\n    <article>\n      <header>\n        摘要\n      </header>\n      <input type=\"text\" [(ngModel)]=\"source\">\n      <textarea [(ngModel)]=\"result\"></textarea>\n      <textarea [(ngModel)]=\"decryptHex\"></textarea>\n      <div>{{decryptText}}</div>\n    <div class=\"select\">\n      <label for=\"digest\">算法</label>\n      <select id=\"digest\" [(ngModel)]=\"digestAlgorithm\" (change)=\"onDigestAlgorithmChange()\">\n        <option>请选择</option>\n        <option value=\"SHA-1\">SHA-1</option>\n        <option value=\"SHA-256\">SHA-256</option>\n        <option value=\"SHA-384\">SHA-384</option>\n        <option value=\"SHA-512\">SHA-512</option>\n      </select>\n      \n    </div>\n    </article>\n    <hr/>\n    <article>\n      <header>\n        加解密\n      </header>\n      <button (click)=\"onCreateUserKeyClick()\">创建秘钥</button>\n      <input type=\"text\" [(ngModel)]=\"key\"/>\n      <div>publicKey:{{publicKey|json}}</div>\n      <div>privateKey:{{privateKey|json}}</div>\n    <div class=\"select\">\n      <label for=\"crypto\">算法</label>\n      <select id=\"crypto\" [(ngModel)]=\"cryptoAlgorithm\" (change)=\"onCryptoAlgorithmChange()\">\n        <optgroup label=\"对称\">\n          <option value=\"AES-CTR\">AES-CTR</option>\n          <option value=\"AES-CBC\">AES/CBC/PKCS7Padding,Java需要BouncyCastleProvider(bcprov-jdk16)</option>\n          <option value=\"AES-GCM\">AES-GCM</option>\n        </optgroup>\n        <optgroup label=\"非对称\">\n          <option value=\"RSA-OAEP\">AES-OAEP</option>\n        </optgroup>\n      </select>\n      <button (click)=\"onDecryptClick()\">解密</button>\n    </div>\n    </article>\n  `\n})\nexport class CryptoComponent implements OnInit {\n  public digestAlgorithm;\n  public cryptoAlgorithm;\n  public source='你好呀你好嘛你好吗你好哦';\n  public result;\n  public decryptHex;\n  public decryptText;\n  public publicKey;\n  public privateKey;\n  public key='12345678';\n  constructor(private cryptoService: CryptoService) {\n\n  }\n  public ngOnInit() {\n\n  }\n  public onDecryptClick(){\n    let buffer = this.hex2bytes(this.result);\n    console.log(buffer);\n    let encryptedKey:any;\n    let alg:any;\n    let format:string;\n    if(this.cryptoAlgorithm=='AES-GCM'){\n      encryptedKey= this.hex2bytes(this.key);\n      console.log(encryptedKey.length);\n      alg = { name: 'AES-GCM', iv: crypto.getRandomValues(new Uint8Array(12)) };\n      format = 'raw';\n      this.aesDecrypt(encryptedKey,buffer,alg,format);\n    }else if(this.cryptoAlgorithm=='AES-CBC'){\n      encryptedKey= this.hex2bytes('31323334353637383930313233343536');\n      console.log(encryptedKey);\n      console.log(encryptedKey.length);\n      alg = { name: 'AES-CBC', iv: this.hex2bytes('31323334353637383930313233343536') };\n      format = 'raw';\n      this.aesDecrypt(encryptedKey,buffer,alg,format);\n    }else if(this.cryptoAlgorithm=='AES-CTR'){\n      encryptedKey= this.hex2bytes(this.key);\n      console.log(encryptedKey.length);\n      alg = { name: 'AES-CTR', counter: crypto.getRandomValues(new Uint8Array(16)),length: 2 };\n      format = 'raw';\n      this.aesDecrypt(encryptedKey,buffer,alg,format);\n    }else if(this.cryptoAlgorithm=='RSA-OAEP'){\n      encryptedKey = { \"alg\": \"RSA-OAEP-256\", \"d\": \"io5o-I0dxjVnVhAGZUOVVZe271W0_r7wonGxAY5-9qoLq9ujt5k992V14WRnluXHZ6wMCOXCQENzpx1yEzMt81VJ2lKEo9u66uniUh8Ma9fptwp0h93C5twmCR9n9ja1BUW_XENCo1BJC234jmzE8iOKNoXMNaRdVBqlFYZzwV5r37-_MO2apeGACW6yKIDf4Arr5GOWWtbtTea3UbNfj4dIbHfrSWq1IAqTPY30f60NFMlaAi2tqhhCQu-sePMU0GfMgWilS3-KwFoyTrQKxNz-P5WJxEBlsBvP9TixiUTJOJm8Z-sVvs2dtKSeil4rftP7-_FwOPPFNwNAj5OMQQ\", \"dp\": \"vsDS2wSKa-Y19hx93nEiJjXvQl5R8dpxWwMHbffJ-eNeoyjkikjnw7tKUsZ0W3ziVGqLR4KZL_JCYE_pgePifx3XGm5Y8TZKg1tbuOIOAEdDZiwcblJrTbfyl_D9gwRItOL7rV3TWFOHbgYKqqRtDQtDSJoNdFyO5TNPwHOHYGc\", \"dq\": \"HKoT-QnX3yWfsO4VukX1dzIAY4vaaAyO0Z9v9aEbEwAva1cgoCkwnfXBBDS5fiWq2EA7UO2aI1zmw3SkojmXD-V_blVbHiEib79akToLZGXCGmvbQ2yX4gMi3bsj1q0I83VpNfPkyqNkmvK3QtoQB3TL8EW_lUEf7zEWkt4AfYE\", \"e\": \"AQAB\", \"ext\": true, \"key_ops\": [ \"decrypt\" ], \"kty\": \"RSA\", \"n\": \"y4lDq1cm-xhN1CJcx_kVUW4GiTaeAdX4dOMcd9rR7fz18j9ehnX8CGuV3IF1Fn1hIa33YBPlFqEgKNyUagZFyjHziNsk10AEz-5DzTDwDZzauxA2o97fYG3g4kAcxMlbehDCR-zOMk45VWOOXWDMXLsKmrjxhnhbTrcZMPdjgmC49M91EO6DHvjHNK79SazSFgS7dmcgLAJv5ZE82tG4NfbiMTE6bq6UdDrr-diNuRHMXSVtT5Z0yY0uT1jkU5pj6xy9CHnkc6gzk_bgDcylNYmjNgE8b5aY7LoDjPXAZuQ5JTPjjq9R4tt33IkbXnhLhKvppziNh8BciJJvfq_Rdw\", \"p\": \"6vvzhtUbxZYKWONphBGJnQ6rRxM8HcwiE1YSwwFBchVH6r-K6XQRrCluWj8yIqRuxvB9We4ELewoOI-Y1zdEWUq-ss8czB5o_q0UvtSxJfojM5E0A6u4zZ7Ffbg0Btdyzdf6HKNlzBy8WMcaJYTmRJwyd4ttHNt1mQtzwnsPSYc\", \"q\": \"3b1MuZahRNHLBArWbpXejeJA9AqTGCR32MksZByL2S3C8ms1pOt5z1yN9Yl6pc55ShCLwmJ61PETl248KI7n3wUOYNbyz0wqFscFGBJFFv_0Zusj_0U8okwNkEHMznhfvjKqCwhNT8dpGw3YhfZq5NRZHNFXHcFOFzzZruoadJE\", \"qi\": \"n-kbNlX6ROgKG_rNndy7IuojhlZBCqmL_di_x92wVFs4qrOJ-okK76dxd6ekqxdUO76UIjUzlsUsCTJsDfMcMSnbu37FlZf7vDEGb2F6FY7gVMyRDS4uOmarHrdMZIt8eymc_Y6jOwmXsEn33f_Uxxmk6YxexVUdGV3R5JEkJw4\" };\n      alg = {name: \"rsa-oaep\", hash: {name: \"sha-256\"}};\n      format = 'jwk';\n    }\n\n  }\n\n  public rasDecrypt(encryptedKey,data,alg,format){\n    console.log('encryptedKey:'+ encryptedKey);\n    this.cryptoService.importKey(format, encryptedKey,alg,true, ['encrypt']).then((key)=>{\n      return this.cryptoService.encrypt(alg, key, data);\n    }).then((result)=>{\n      this.result = this.hex(result);\n    });\n  }\n  public aesDecrypt(encryptedKey,data,alg,format){\n    console.log(\"encryptedKey::\",encryptedKey);\n    this.cryptoService.digest('SHA-256', encryptedKey).then((keyData)=>{\n      return this.cryptoService.importKey(format, encryptedKey, alg, true, ['decrypt']);\n    }).then((key)=>{\n      console.log(key);\n      return this.cryptoService.decrypt(alg, key, data);\n    }).then((result)=>{\n      this.decryptHex = this.hex(result);\n      this.decryptText = this.string(this.decryptHex);\n    });\n  }\n  public rasEncrypt(encryptedKey,data,alg,format){\n    console.log('encryptedKey:'+ encryptedKey);\n    this.cryptoService.importKey(format, encryptedKey,alg,true, ['encrypt']).then((key)=>{\n      return this.cryptoService.encrypt(alg, key, data);\n    }).then((result)=>{\n      this.result = this.hex(result);\n    });\n  }\n  public aesEncrypt(encryptedKey,data,alg,format){\n    this.cryptoService.digest('SHA-1', encryptedKey).then((keyData)=>{\n      return this.cryptoService.importKey(format, encryptedKey, alg, true, ['encrypt']);\n    }).then((key)=>{\n      console.log(key);\n      console.log(data);\n      return this.cryptoService.encrypt(alg, key, data);\n    }).then((result)=>{\n      console.log(result);\n      this.result = this.hex(result);\n    });\n  }\n  public onCreateUserKeyClick(){\n    let algorithmKeyGen = {\n      name: \"RSA-OAEP\",\n      hash: {name: \"sha-256\"},\n      modulusLength: 2048,\n      publicExponent: new Uint8Array([0x01, 0x00, 0x01])\n    };\n    let nonExtractable = false;\n    let publicKey = \"\";\n    let privateKey = \"\";\n    let keyPairs;\n    this.cryptoService.generateKey(algorithmKeyGen, true, ['encrypt', 'decrypt']).then((result)=>{\n      keyPairs = result;\n      return Promise.all([\n        this.cryptoService.exportKey(\"jwk\", keyPairs.publicKey),\n        this.cryptoService.exportKey(\"jwk\", keyPairs.privateKey)]);\n    }).then((keyPairs)=>{\n        console.log(keyPairs);\n        this.publicKey = keyPairs[0];\n        this.privateKey = keyPairs[1];\n    });\n  }\n  public onCryptoAlgorithmChange(){\n    let buffer = this.bytes(this.source);\n    console.log(buffer);\n    let encryptedKey:any;\n    let alg:any;\n    let format:string;\n    if(this.cryptoAlgorithm=='AES-GCM'){\n      encryptedKey= this.bytes(this.key);\n      console.log(encryptedKey.length);\n      alg = { name: 'AES-GCM', iv: crypto.getRandomValues(new Uint8Array(12)) };\n      format = 'raw';\n      this.aesEncrypt(encryptedKey,buffer,alg,format);\n    }else if(this.cryptoAlgorithm=='AES-CBC'){\n      encryptedKey= this.hex2bytes('31323334353637383930313233343536');\n      console.log(encryptedKey);\n      console.log(encryptedKey.length);\n      alg = { name: 'AES-CBC', iv: this.hex2bytes('31323334353637383930313233343536') };\n      format = 'raw';\n      this.aesEncrypt(encryptedKey,buffer,alg,format);\n    }else if(this.cryptoAlgorithm=='AES-CTR'){\n      encryptedKey= this.bytes(this.key);\n      console.log(encryptedKey.length);\n      alg = { name: 'AES-CTR', counter: crypto.getRandomValues(new Uint8Array(16)),length: 2 };\n      format = 'raw';\n      this.aesEncrypt(encryptedKey,buffer,alg,format);\n    }else if(this.cryptoAlgorithm=='RSA-OAEP'){\n      encryptedKey = { \"alg\": \"RSA-OAEP-256\", \"e\": \"AQAB\", \"ext\": true, \"key_ops\": [ \"encrypt\" ], \"kty\": \"RSA\", \"n\": \"y4lDq1cm-xhN1CJcx_kVUW4GiTaeAdX4dOMcd9rR7fz18j9ehnX8CGuV3IF1Fn1hIa33YBPlFqEgKNyUagZFyjHziNsk10AEz-5DzTDwDZzauxA2o97fYG3g4kAcxMlbehDCR-zOMk45VWOOXWDMXLsKmrjxhnhbTrcZMPdjgmC49M91EO6DHvjHNK79SazSFgS7dmcgLAJv5ZE82tG4NfbiMTE6bq6UdDrr-diNuRHMXSVtT5Z0yY0uT1jkU5pj6xy9CHnkc6gzk_bgDcylNYmjNgE8b5aY7LoDjPXAZuQ5JTPjjq9R4tt33IkbXnhLhKvppziNh8BciJJvfq_Rdw\" };\n      alg = {name: \"rsa-oaep\", hash: {name: \"sha-256\"}};\n      format = 'jwk';\n    }\n  }\n\n  public onDigestAlgorithmChange(){\n      let buffer = this.bytes(this.source);\n      this.cryptoService.digest(this.digestAlgorithm,buffer).then((result)=>{\n        this.result = this.hex(result);\n      });\n  }\n  private hex2bytes(arr:string){\n    return new Uint8Array(arr.split(/(.{2})/g).filter((v)=>{return v.length>0}).map(function(v){return parseInt(v,16)}));\n   }\n  private bytes(string){\n    return new Uint8Array(encodeURIComponent(string).split('%').filter(function(v,i,arr){return v.length>0}).map(function(v){return parseInt(v,16)}));\n  }\n  private string(bytes){\n    return decodeURIComponent(bytes.replace(/(.{2})/g, '%$1'));\n  }\n  private hex(buffer) {\n    let hexCodes = [];\n    let view = new DataView(buffer);\n    for (let i = 0; i < view.byteLength; i++) {\n      let value = view.getUint8(i);\n      let stringValue = value<15?'0'+value.toString(16):value.toString(16);\n      hexCodes.push(stringValue);\n    }\n    return hexCodes.join(\"\");\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/_angular2-template-loader@0.6.2@angular2-template-loader!./src/app/+demo/+crypto/crypto.component.ts","import { Injectable } from '@angular/core';\n/**\n * https://www.w3.org/TR/WebCryptoAPI/\n *\n *Algorithm name\tencrypt\tdecrypt\tsign\tverify\tdigest\tgenerateKey\tderiveKey\tderiveBits\timportKey\texportKey\twrapKey\tunwrapKey\n *RSASSA-PKCS1-v1_5\t({ kty: \"RSA\",  alg: \"RS1\" },{ name: \"RSASSA-PKCS1-v1_5\",  hash: { name: \"SHA-1\" } })\t\t✔\t✔\t\t✔\t\t\t✔\t✔\n *RSA-PSS\t\t\t✔\t✔\t\t✔\t\t\t✔\t✔\n *RSA-OAEP\t✔\t✔\t\t\t\t✔\t\t\t✔\t✔\t✔\t✔\n *ECDSA\t\t\t✔\t✔\t\t✔\t\t\t✔\t✔\n *ECDH\t\t\t\t\t\t✔\t✔\t✔\t✔\t✔\n *AES-CTR\t✔\t✔\t\t\t\t✔\t\t\t✔\t✔\t✔\t✔\n *AES-CBC\t✔\t✔\t\t\t\t✔\t\t\t✔\t✔\t✔\t✔\n *AES-GCM\t✔\t✔\t\t\t\t✔\t\t\t✔\t✔\t✔\t✔\n *AES-KW\t\t\t\t\t\t✔\t\t\t✔\t✔\t✔\t✔\n *HMAC\t\t\t✔\t✔\t\t✔\t\t\t✔\t✔\n *SHA-1\t\t\t\t\t✔\n *SHA-256\t\t\t\t\t✔\n *SHA-384\t\t\t\t\t✔\n *SHA-512\t\t\t\t\t✔\n *HKDF\t\t\t\t\t\t\t✔\t✔\t✔\n *PBKDF2\t\t\t\t\t\t\t✔\t✔\t✔\n *\"encrypt\", \"decrypt\", \"sign\", \"verify\", \"deriveKey\", \"deriveBits\", \"wrapKey\" and \"unwrapKey\".\n * { kty: \"RSA\",  alg: \"RS1\" }\n { name: \"RSASSA-PKCS1-v1_5\",  hash: { name: \"SHA-1\" }}\n\n { kty: \"RSA\",  alg: \"RS256\" }\n { name: \"RSASSA-PKCS1-v1_5\",  hash: { name: \"SHA-256\" }}\n\n { kty: \"RSA\",  alg: \"RS384\" }\n { name: \"RSASSA-PKCS1-v1_5\",  hash: { name: \"SHA-384\" }}\n\n { kty: \"RSA\",  alg: \"RS512\" }\n { name: \"RSASSA-PKCS1-v1_5\",  hash: { name: \"SHA-512\" }}\n\n { kty: \"RSA\",  alg: \"PS256\" }\n { name: \"RSA-PSS\",  hash: { name: \"SHA-256\" }}\n\n { kty: \"RSA\",  alg: \"PS384\" }\n { name: \"RSA-PSS\",  hash: { name: \"SHA-384\" }}\n\n { kty: \"RSA\",  alg: \"PS512\" }\n { name: \"RSA-PSS\",  hash: { name: \"SHA-512\" }}\n\n { kty: \"RSA\",  alg: \"RSA-OAEP\" }\n { name: \"RSA-OAEP\",  hash: { name: \"SHA-1\" }}\n\n { kty: \"RSA\",  alg: \"RSA-OAEP-256\" }\n { name: \"RSA-OAEP\",  hash: { name: \"SHA-256\" }}\n\n { kty: \"RSA\",  alg: \"RSA-OAEP-384\" }\n { name: \"RSA-OAEP\",  hash: { name: \"SHA-384\" }}\n\n { kty: \"RSA\",  alg: \"RSA-OAEP-512\" }\n { name: \"RSA-OAEP\",  hash: { name: \"SHA-512\" }}\n\n { kty: \"EC\",  alg: \"ES256\" }\n { name: \"ECDSA\",  namedCurve: \"P-256\"  hash: { name: \"SHA-256\" }}\n\n { kty: \"EC\",  alg: \"ES384\" }\n { name: \"ECDSA\",  namedCurve: \"P-384\"  hash: { name: \"SHA-384\" }}\n\n { kty: \"EC\",  alg: \"ES512\" }\n\n { name: \"ECDSA\",  namedCurve: \"P-521\"  hash: { name: \"SHA-512\" }}\n\n { kty: \"oct\",  alg: \"A128CTR\" }\n { name: \"AES-CTR\",  length: 128 }\n\n { kty: \"oct\",  alg: \"A192CTR\" }\n { name: \"AES-CTR\",  length: 192 }\n\n\n { kty: \"oct\",  alg: \"A256CTR\" }\n { name: \"AES-CTR\",  length: 256 }\n\n { kty: \"oct\",  alg: \"A128CBC\" }\n { name: \"AES-CBC\",  length: 128 }\n\n { kty: \"oct\",  alg: \"A192CBC\" }\n { name: \"AES-CBC\",  length: 192 }\n\n { kty: \"oct\",  alg: \"A256CBC\" }\n { name: \"AES-CBC\",  length: 256 }\n\n { kty: \"oct\",  alg: \"A128KW\" }\n\n { name: \"AES-KW\",  length: 128 }\n\n { kty: \"oct\",  alg: \"A192KW\" }\n { name: \"AES-KW\",  length: 192 }\n\n { kty: \"oct\",  alg: \"A256KW\" }\n { name: \"AES-KW\",  length: 256 }\n\n { kty: \"oct\",  alg: \"A128GCM\" }\n { name: \"AES-GCM\",  length: 128 }\n\n { kty: \"oct\",  alg: \"A192GCM\" }\n { name: \"AES-GCM\",  length: 192 }\n\n { kty: \"oct\",  alg: \"A256GCM\" }\n { name: \"AES-GCM\",  length: 256 }\n\n { kty: \"oct\",  alg: \"A128GCMKW\" }\n { name: \"AES-GCM\",  length: 128 }\n\n { kty: \"oct\",  alg: \"A192GCMKW\" }\n { name: \"AES-GCM\",  length: 192 }\n\n { kty: \"oct\",  alg: \"A256GCMKW\" }\n { name: \"AES-GCM\",  length: 256 }\n\n { kty: \"oct\",  alg: \"HS1\" }\n { name: \"HMAC\",  hash: { name: \"SHA-1\" }}\n\n { kty: \"oct\",  alg: \"HS256\" }\n { name: \"HMAC\",  hash: { name: \"SHA-256\" }}\n\n { kty: \"oct\",  alg: \"HS384\" }\n { name: \"HMAC\",  hash: { name: \"SHA-384\" }}\n\n { kty: \"oct\",  alg: \"HS512\" }\n { name: \"HMAC\",  hash: \"SHA-512\" }\n AES加密模式和填充方式\n\n 算法/模式/填充                16字节加密后数据长度        不满16字节加密后长度\n AES/CBC/NoPadding             16                          不支持\n AES/CBC/PKCS5Padding          32                          16\n AES/CBC/PKCS7Padding  (bcprov-jdk16 支持)        32                          16\n AES/CBC/ISO10126Padding       32                          16\n AES/CFB/NoPadding             16                          原始数据长度\n AES/CFB/PKCS5Padding          32                          16\n AES/CFB/ISO10126Padding       32                          16\n AES/ECB/NoPadding             16                          不支持\n AES/ECB/PKCS5Padding          32                          16\n AES/ECB/ISO10126Padding       32                          16\n AES/OFB/NoPadding             16                          原始数据长度\n AES/OFB/PKCS5Padding          32                          16\n AES/OFB/ISO10126Padding       32                          16\n AES/PCBC/NoPadding            16                          不支持\n AES/PCBC/PKCS5Padding         32                          16\n AES/PCBC/ISO10126Padding      32                          16\n */\n@Injectable()\nexport class CryptoService {\n  private crypto = window.crypto;\n\n  public genRandomNumbers(array){\n    return this.crypto.getRandomValues(array);\n  }\n\n  /**\n   * Parameters\n\n   algorithm is an object specifying the encryption function to be used and its parameters;  if there are no parameters, algorithm can be a DOMString with the algorithm name. Supported values¹ are:\n   {\"name\": \"AES-CBC\", iv} where iv is a 16-byte BufferSource initialization vector (generated by RandomSource.getRandomValues()).\n   {\"name\": \"AES-CTR\", counter, length} where counter is an initialised 16-byte BufferSource counter block, and length is the length (in bits) of the part of the counter block that is incremented.\n   {\"name\": \"AES-GCM\", iv[, additionalData, tagLength]} where iv is a BufferSource initialization vector up to 2⁶⁴−1 bytes long; additionalData is a BufferSource authentication data and tagLength is the length of the authentication tag.\n   {\"name\": \"RSA-OAEP\"[, label]} where label is an optional label to associate with the message.\n   key is a CryptoKey containing the key to be used for signing.\n   data is a BufferSource containing the data to be encrypted, the plaintext.\n   Return value\n\n   result is a Promise that returns the ciphertext generated by the encryption of the plaintext as an ArrayBuffer.\n   Exceptions\n\n   The promise is rejected when the following exceptions are encountered:\n\n   InvalidAccessError\n   when the requested operation is not valid for the provided key (e.g. invalid encryption algorithm, or invalid key for specified encryption algorithm).\n   OperationError\n   when the operation failed for an operation-specific reason (e.g. algorithm parameters of invalid sizes, or AES-GCM plaintext longer than 2³⁹−256 bytes).\n   Example\n   const ptUtf8 = new TextEncoder().encode('my plaintext');\n\n   const pwUtf8 = new TextEncoder().encode('my password');\n   const pwHash = await crypto.subtle.digest('SHA-256', pwUtf8);\n\n   const iv = crypto.getRandomValues(new Uint8Array(12));\n   const alg = { name: 'AES-GCM', iv: iv };\n   const key = await crypto.subtle.importKey('raw', pwHash, alg, false, ['encrypt']);\n\n   const ctBuffer = await crypto.subtle.encrypt(alg, key, ptUtf8);\n   The password and the iv will be required for the SubtleCrypto.decrypt() operation.\n\n   * @param algorithm\n   * @param key\n   * @param data\n   * @returns {PromiseLike<ArrayBuffer>}\n   */\n  public encrypt(algorithm, key, data){\n    return this.crypto.subtle.encrypt(algorithm, key, data);\n  }\n\n  /**\n   * Parameters\n\n   algorithm is an object specifying the encryption function to be used and its parameters; if there are no parameters, algorithm can be a DOMString with the algorithm name. Supported values¹ are:\n   {\"name\": \"AES-CBC\", iv} where iv is as supplied to SubtleCrypto.encrypt().\n   {\"name\": \"AES-CTR\", counter, length} where counter and length are as supplied to SubtleCrypto.encrypt().\n   {\"name\": \"AES-GCM\", iv[, additionalData, tagLength]} where iv, additionalData, tagLength are as supplied to SubtleCrypto.encrypt().\n   {\"name\": \"RSA-OAEP\"[, label]} where label is as supplied to SubtleCrypto.encrypt().\n   key is a CryptoKey containing the key to be used for decryption.\n   data is a BufferSource containing the data to be decrypted, the ciphertext.\n   Return value\n\n   result is a Promise that returns the plaintext generated by the decryption of the ciphertext.\n   Exceptions\n\n   The promise is rejected when the following exceptions are encountered:\n\n   InvalidAccessError\n   when the requested operation is not valid for the provided key (e.g. invalid encryption algorithm, or invalid key for specified encryption algorithm).\n   OperationError\n   when the operation failed for an operation-specific reason (e.g. algorithm parameters of invalid sizes, or the result of the decryption is a fail).\n   Example\n   const pwUtf8 = new TextEncoder().encode('my password');\n   const pwHash = await crypto.subtle.digest('SHA-256', pwUtf8);\n\n   const alg = { name: 'AES-GCM', iv: iv };\n   const key = await crypto.subtle.importKey('raw', pwHash, alg, false, ['decrypt']);\n\n   const ptBuffer = await crypto.subtle.decrypt(alg, key, ctBuffer);\n\n   const plaintext = new TextDecoder().decode(ptBuffer);\n   The iv is as supplied to SubtleCrypto.encrypt(); the ctBuffer is the ciphertext returned from SubtleCrypto.encrypt().\n\n\n   */\n  public decrypt(algorithm, key, data){\n      return this.crypto.subtle.decrypt(algorithm, key, data);\n  }\n\n  /**\n   * SyntaxEDIT\n   var hash = crypto.subtle.digest(algo, buffer);\n   Parameters\n\n   algo is a DOMString defining the hash function to use. Supported values are: SHA-1, SHA-256, SHA-384, and SHA-512.\n   buffer is an ArrayBuffer or an ArrayBufferView containing the data to be hashed using the hashing algorithm.\n   Return value\n\n   hash is a Promise that returns the hash on success.\n   ExampleEDIT\n   Here's an example that computes the sha256 of a string and display its hex digest.\n\n   function sha256(str) {\n  // We transform the string into an arraybuffer.\n  var buffer = new TextEncoder(\"utf-8\").encode(str);\n  return crypto.subtle.digest(\"SHA-256\", buffer).then(function (hash) {\n    return hex(hash);\n  });\n}\n\n   function hex(buffer) {\n  var hexCodes = [];\n  var view = new DataView(buffer);\n  for (var i = 0; i < view.byteLength; i += 4) {\n    // Using getUint32 reduces the number of iterations needed (we process 4 bytes each time)\n    var value = view.getUint32(i)\n    // toString(16) will give the hex representation of the number without padding\n    var stringValue = value.toString(16)\n    // We use concatenation and slice for padding\n    var padding = '00000000'\n    var paddedValue = (padding + stringValue).slice(-padding.length)\n    hexCodes.push(paddedValue);\n  }\n\n  // Join all the hex strings into one\n  return hexCodes.join(\"\");\n}\n\n   sha256(\"foobar\").then(function(digest) {\n  console.log(digest);\n}); // outputs \"c3ab8ff13720e8ad9047dd39466b3c8974e592c2fa383d4a3960714caef0c4f2\"\n   * @returns {PromiseLike<ArrayBuffer>}\n   */\n\n  public digest(algo, buffer){\n      return this.crypto.subtle.digest(algo, buffer);\n  }\n\n  /**\n   * SyntaxEDIT\n   var result = crypto.deriveKey(algo, masterKey, derivedKeyAlgo, extractable, keyUsages);\n   Parameters\n\n   algo is an object defining the derivation algorithm to use. Supported values are:\n   {\"name\": \"ECDH\", \"public\": publicKey}\n   {\"name\": \"DH\", \"public\": publicKey}\n   {\"name\": \"PBKDF2\", salt, iterations, hash} where salt is an ArrayBuffer or an ArrayBufferView, iterations is the number of iterations and hash is a DOMString identifying the hashing algorithm to use.\n   {\"name\": \"HKDF-CTR\", hash, label, context}\n   masterKey is a CryptoKey representing the master key to be used by the key derivation algorithm.\n   derivedKeyAlgo is an object defining the algorithm the derived key will be used for or a DOMString as a shortcut for {\"name\": derivedKeyAlgo}. For AES a length property is also required, possible values are 128, 192 or 256 bits.\n   extractable is a Boolean indicating if the key can be extracted from the CryptoKey object at a later stage.\n   keyUsages  is an Array indicating what can be done with the derivated key. Possible values of the array are:\n   \"encrypt\", allowing the key to be used for encrypting messages.\n   \"decrypt\", allowing the key to be used for decrypting messages.\n   \"sign\", allowing the key to be used for signing messages.\n   \"verify\", allowing the key to be used for verifying the signature of messages.\n   \"deriveKey\", allowing the key to be used as a base key when deriving a new key.\n   \"deriveBits\", allowing the key to be used as a base key when deriving bits of data for use in cryptographic primitives.\n   \"wrapKey\", allowing the key to wrap a symmetric key for usage (transfer, storage) in unsecure environments.\n   \"unwrapKey\", allowing the key to unwrap a symmetric key for usage (transfer, storage) in unsecure environments.\n   Return value\n\n   result is a Promise that returns the derivated key as a CryptoKey or a CryptoKeyPair.\n   Exceptions\n\n   The promise is rejected when one of the following exceptions are encountered:\n\n   InvalidAccessError when the master key is not a key for the requested derivation algorithm or if the CryptoKey.usages value of that key doesn't contain \"deriveKey\".\n   NotSupported when trying to use an algorithm that is either unknown or isn't suitable for derivation, or if the algorithm requested for the derived key doesn't define a key length.\n   SyntaxError when keyUsages is empty but the unwrapped key is of type \"secret\" or \"private\".\n   ExampleEDIT\n   Here's an example showing how to use deriveKey() to create a Secure Remote Password (also known as Proof of Secret) from a user's password.\n\n   // salt should be Uint8Array or ArrayBuffer\n   var saltBuffer = Unibabel.hexToBuffer('e85c53e7f119d41fd7895cdc9d7bb9dd');\n\n   // don't use naïve approaches for converting text, otherwise international\n   // characters won't have the correct byte sequences. Use TextEncoder when\n   // available or otherwise use relevant polyfills\n   var passphraseKey = Unibabel.utf8ToBuffer(\"I hëart årt and £$¢!\");\n\n   // You should firstly import your passphrase Uint8array into a CryptoKey\n   window.crypto.subtle.importKey(\n   'raw',\n   passphraseKey,\n   {name: 'PBKDF2'},\n   false,\n   ['deriveBits', 'deriveKey']\n   ).then(function(key) {\n\n  return window.crypto.subtle.deriveKey(\n    { \"name\": 'PBKDF2',\n      \"salt\": saltBuffer,\n      // don't get too ambitious, or at least remember\n      // that low-power phones will access your app\n      \"iterations\": 100,\n      \"hash\": 'SHA-256'\n    },\n    key,\n\n    // Note: for this demo we don't actually need a cipher suite,\n    // but the api requires that it must be specified.\n\n    // For AES the length required to be 128 or 256 bits (not bytes)\n    { \"name\": 'AES-CBC', \"length\": 256 },\n\n    // Whether or not the key is extractable (less secure) or not (more secure)\n    // when false, the key can only be passed as a web crypto object, not inspected\n    true,\n\n    // this web crypto object will only be allowed for these functions\n    [ \"encrypt\", \"decrypt\" ]\n  )\n}).then(function (webKey) {\n\n  return crypto.subtle.exportKey(\"raw\", webKey);\n\n}).then(function (buffer) {\n\n    var proofOfSecret = Unibabel.bufferToHex(buffer);\n    // this proof-of-secret / secure-remote password\n    // can now be sent in place of the user's password\n});\n   * @param algo\n   * @param masterKey\n   * @param derivedKeyAlgo\n   * @param extractable\n   * @param keyUsages\n   */\n  public deriveKey(algo, masterKey, derivedKeyAlgo, extractable, keyUsages){\n      return this.crypto.subtle.deriveKey(algo, masterKey, derivedKeyAlgo, extractable, keyUsages);\n  }\n\n  /**\n   * Parameters\n\n   format is an enumerated value describing the data format in which the key has to be exported. It can be one of the following:\n   \"raw\", the key as an array of bytes, usually a secret key.\n   \"pkcs8\" a private key, in the IETF Public Key-Cryptographic Standard Encryption #8.\n   \"spki\", usually a public key, in the Simple public key infrastructure standard\n   \"jwk\", the key in the JSON Web Key format.\n   key is the CryptoKey to export.\n   Return value\n\n   result is a Promise that returns the key in the requested format.\n   Exceptions\n\n   The promise is rejected when one of the following exceptions is encountered:\n\n   InvalidAccessError when trying to export an non-extractable key.\n   NotSupported when trying to export in an unknown format.\n   TypeError when trying to use an invalid format.\n   * @param format\n   * @param key\n   */\n  public exportKey(format, key){\n      return this.crypto.subtle.exportKey(format, key);\n  }\n\n  /**\n   * Parameters\n\n   format is an enumerated value describing the data format of the key to imported. It can be one of the following:\n   \"raw\", the key as an array of bytes, usually a secret key.\n   \"pkcs8\" a private key, in the IETF Public Key-Cryptographic Standard Encryption #8.\n   \"spki\", usually a public key, in the Simple public key infrastructure standard\n   \"jwk\", the key in the JSON Web Key format.\n   keyData is an ArrayBuffer or a JSONWebKey containing the key in the given format.\n   algo is a DOMString defining the signature function to use. Supported values are: AES-CTR, AES-CBC, AES-GCM, RSA-OAEP, AES-KW, HMAC, RSASSA-PKCS1-v1_5, ECDSA, ECDH, DH.\n   extractable is a Boolean indicating if the key can be extracted from the CryptoKey object at a later stage.\n   usages is an Array indicating what can be done with the key. Possible values of the array are:\n   \"encrypt\", allowing the key to be used for encrypting messages.\n   \"decrypt\", allowing the key to be used for decrypting messages.\n   \"sign\", allowing the key to be used for signing messages.\n   \"verify\", allowing the key to be used for verifying the signature of messages.\n   \"deriveKey\", allowing the key to be used as a base key when deriving a new key.\n   \"deriveBits\", allowing the key to be used as a base key when deriving bits of data for use in cryptographic primitives.\n   \"wrapKey\", allowing the key to wrap a symmetric key for usage (transfer, storage) in unsecure environments.\n   \"unwrapKey\", allowing the key to unwrap a symmetric key for usage (transfer, storage) in unsecure environments.\n   Return value\n\n   result is a Promise that returns the generated CryptoKey.\n   Exceptions\n\n   The promise is rejected when one of the following exceptions is encountered:\n\n   SyntaxError when keyUsages is empty but the unwrapped key is of type \"secret\" or \"private\".\n   TypeError when trying to use an invalid format or if the keyData is not suited for that format.\n   */\n  public importKey(format, keyData, algo, extractable, usages){\n    return this.crypto.subtle.importKey(format, keyData, algo, extractable, usages);\n  }\n\n  /**\n   * Parameters\n\n   algo is a dictionary object defining the key generation function to use. Supported algo are: AES-CBC, AES-CTR, AES-GCM, RSA-OAEP, AES-KW, HMAC, RSASSA-PKCS1-v1_5, ECDSA, ECDH, and DH.\n   extractable is a Boolean indicating if the key can be extracted from the CryptoKey object at a later stage.\n   keyUsages  is an Array indicating what can be done with the newly generated key. Possible values of the array are:\n   \"encrypt\", allowing the key to be used for encrypting messages.\n   \"decrypt\", allowing the key to be used for decrypting messages.\n   \"sign\", allowing the key to be used for signing messages.\n   \"verify\", allowing the key to be used for verifying the signature of messages.\n   \"deriveKey\", allowing the key to be used as a base key when deriving a new key.\n   \"deriveBits\", allowing the key to be used as a base key when deriving bits of data for use in cryptographic primitives.\n   \"wrapKey\", allowing the key to wrap a symmetric key for usage (transfer, storage) in unsecure environments.\n   \"unwrapKey\", allowing the key to unwrap a symmetric key for usage (transfer, storage) in unsecure environments.\n   Return value\n\n   result is a Promise that returns the generated key as a CryptoKey or a CryptoKeyPair.\n   Exceptions\n\n   The promise is rejected when the following exception is encountered:\n\n   InvalidAccessError when the signing key is not a key for the request signing algorithm or when trying to use an algorithm that is either unknown or isn't suitable for signing.\n\n   * @param algo\n   * @param extractable\n   * @param keyUsages\n   * @returns {PromiseLike<CryptoKeyPair|CryptoKey>}\n   */\n  public generateKey(algo, extractable, keyUsages){\n    return this.crypto.subtle.generateKey(algo, extractable, keyUsages);\n  }\n\n  /**\n   * Parameters\n\n   algo is a DOMString defining the signature function to use. Supported values are: HMAC, RSASSA-PKCS1-v1_5, and ECDSA.\n   key is a CryptoKey containing the private key to be used for signing.\n   text2sign is a ArrayBuffer or an ArrayBufferView containing the data to be signed.\n   Return value\n\n   signature is a Promise that returns the signature on success.\n   Exceptions\n\n   The promise is rejected when the following exception is encountered:\n\n   InvalidAccessError when the signing key is not a key for the request signing algorithm or when trying to use an algorithm that is either unknown or isn't suitable for signing.\n   * @param algo\n   * @param key\n   * @param text2sign\n   */\n  public sign(algo, key, text2sign){\n    return this.crypto.subtle.sign(algo, key, text2sign);\n  }\n\n  /**\n   * Parameters\n\n   signature is a ArrayBuffer or an ArrayBufferView containing the signature to verify.\n   text2verify is a ArrayBuffer or an ArrayBufferView containing the data whose signature as to be verified.\n   key is a CryptoKey containing the key to be used to verify the signature. It is the secret key for a symmetric algorithm and the public key for an asymmetric algorithm.\n   algo is a DOMString defining the signature function to use. Supported values are: HMAC, RSASSA-PKCS1-v1_5, and ECDSA.\n   Return value\n\n   result is a Promise that returns a Boolean indicating if the signature has been a success on success.\n   Exceptions\n\n   The promise is rejected when the following exception is encountered:\n\n   InvalidAccessError when the encryption key is not a key for the requested verifying algorithm or when trying to use an algorithm that is either unknown or isn't suitable for a verify operation.\n   * @param algo\n   * @param key\n   * @param signature\n   * @param text2verify\n   */\n  public verify(algo, key, signature, text2verify){\n    return this.crypto.subtle.verify(algo, key, signature, text2verify);\n  }\n\n  /**\n   * Parameters\n\n   format is an enumerated value describing the data format of the key to unwrapped. It can be one of the following:\n   \"raw\", the key as an array of bytes, usually a secret key.\n   \"pkcs8\" a private key, in the IETF Public Key-Cryptographic Standard Encryption #8.\n   \"spki\", usually a public key, in the Simple public key infrastructure standard\n   \"jwk\", the key in the JSON Web Key format.\n   wrappedKey is a ArrayBuffer or a ... containing the wrapped key in the given format.\n   unwrappingKey is the CryptoKey to use to unwrap.\n   unwrapAlgo is the DOMString} representing the algorithm used to perform the unwrapping. It is one of the following: AES-CBC, AES-CTR, AES-GCM, RSA-OAEP, and AES-KW.\n   unwrappedKeyAlgo is the DOMString} representing the algorithm of the wrapped key.\n   extractable is a Boolean indicating if the key can be extracted from the CryptoKey object at a later stage.\n   keyUsages  is an Array indicating what can be done with the unwrapped key. Possible values of the array are:\n   \"encrypt\", allowing the key to be used for encrypting messages.\n   \"decrypt\", allowing the key to be used for decrypting messages.\n   \"sign\", allowing the key to be used for signing messages.\n   \"verify\", allowing the key to be used for verifying the signature of messages.\n   \"deriveKey\", allowing the key to be used as a base key when deriving a new key.\n   \"deriveBits\", allowing the key to be used as a base key when deriving bits of data for use in cryptographic primitives.\n   \"wrapKey\", allowing the key to wrap a symmetric key for usage (transfer, storage) in unsecure environments.\n   \"unwrapKey\", allowing the key to unwrap a symmetric key for usage (transfer, storage) in unsecure environments.\n   Return value\n\n   result is a Promise that returns the unwrapped key as a CryptoKey\n   Exceptions\n\n   The promise is rejected when one of the following exceptions is encountered:\n\n   InvalidAccessError when the unwrapping key is not a key for the requested unwrap algorithm or if the CryptoKey.usages value of that key doesn't contain \"unwrap\".\n   NotSupported when trying to use an algorithm that is either unknown or isn't suitable for encryption or wrapping.\n   SyntaxError when keyUsages is empty but the unwrapped key is of type \"secret\" or \"private\".\n   TypeError when trying to use an invalid format.\n   */\n  public unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgo, unwrappedKeyAlgo, extractable, keyUsages){\n      return this.crypto.subtle.unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgo, unwrappedKeyAlgo, extractable, keyUsages);\n  }\n\n  /**\n   * Parameters\n\n   format is an enumerated value describing the data format in which the key must be wrapped. It can be one of the following:\n   \"raw\", the key as an array of bytes, usually a secret key.\n   \"pkcs8\" a private key, in the IETF Public Key-Cryptographic Standard Encryption #8.\n   \"spki\", usually a public key, in the Simple public key infrastructure standard\n   \"jwk\", the key in the JSON Web Key format.\n   key is the CryptoKey to wrap.\n   wrappingkey is the CryptoKey used to perform the wrapping.\n   wrapAlgo is the DOMString} representing the algorithm used to perform the wrapping. It is one of the following: AES-CBC, AES-CTR, AES-GCM, RSA-OAEP, and AES-KW.\n   Return value\n\n   result is a Promise that returns the wrapped key in the requested format.\n   Exceptions\n\n   The promise is rejected when one of the following exceptions is encountered:\n\n   InvalidAccessError when the wrapping key is not a key for the requested wrap algorithm.\n   NotSupported when trying to use an algorithm that is either unknown or isn't suitable for encryption or wrapping.\n   TypeError when trying to use an invalid format.\n   */\n  public wrapKey(format, key, wrappingKey, wrapAlgo){\n    return this.crypto.subtle.wrapKey(format, key, wrappingKey, wrapAlgo);\n  }\n  public getRandomValues(arr){\n    return this.crypto.getRandomValues(arr);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/_angular2-template-loader@0.6.2@angular2-template-loader!./src/app/+demo/+crypto/crypto.service.ts","import { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { NgModule } from '@angular/core';\nimport { RouterModule } from '@angular/router';\n\nimport { routes } from './crypto.routes';\nimport { CryptoComponent } from './crypto.component';\nimport { CryptoService } from './crypto.service';\nconsole.log('`Person CURD` bundle loaded asynchronously');\n\n@NgModule({\n  declarations: [\n    CryptoComponent\n  ],\n  imports: [\n    CommonModule,\n    FormsModule,\n    RouterModule.forChild(routes),\n  ],\n  providers: [\n    CryptoService\n  ]\n})\nexport class CryptoModule {\n  public static routes = routes;\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/_angular2-template-loader@0.6.2@angular2-template-loader!./src/app/+demo/+crypto/crypto.module.ts","import { CryptoComponent } from './crypto.component';\n\nexport const routes = [\n  { path: '', component: CryptoComponent,  pathMatch: 'full' },\n];\n\n\n\n// WEBPACK FOOTER //\n// node_modules/_angular2-template-loader@0.6.2@angular2-template-loader!./src/app/+demo/+crypto/crypto.routes.ts","export { CryptoModule } from './crypto.module';\n\n\n\n// WEBPACK FOOTER //\n// node_modules/_angular2-template-loader@0.6.2@angular2-template-loader!./src/app/+demo/+crypto/index.ts"],"mappings":";;;;;;;;;;;AAAA;AAMA;AACA;AAmDA;AAUA;AAAA;AAPA;AAMA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvKA;AAjDA;AACA;AACA;AA8CA;AAWA;AAVA;AAyKA;AAAA;AAzKA;;;;;;;;;;;;;AC1DA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6IA;AAEA;AADA;AAEA;AAobA;AAlbA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0FA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;AAiBA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;AAmBA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;AApbA;AADA;AACA;AAqbA;AAAA;AArbA;;;;;;;;;;;;;;;;;;;AChJA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAeA;AAAA;AAEA;AADA;AADA;AAbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAFA;;;;;;;;;ACvBA;AAAA;AAAA;AAEA;AACA;AACA;;;;;;;;;ACJA;AAAA;AAAA;AAAA;;;;;A","sourceRoot":""}